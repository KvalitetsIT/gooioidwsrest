package gizmo

import (
	"net/http"
	"io/ioutil"
	"fmt"
	"bytes"
	"io"
	"strings"
	"encoding/xml"
	"encoding/base64"
//	"encoding/binary"

	"math/big"

	"regexp"

	"crypto/rsa"
        "crypto/x509"
        "encoding/pem"

	"github.com/russellhaering/gosaml2/types"
	saml2 "github.com/russellhaering/gosaml2"
	dsig "github.com/russellhaering/goxmldsig"
	dsigtypes "github.com/russellhaering/goxmldsig/types"
	"github.com/beevik/etree"
)

var whiteSpace = regexp.MustCompile("\\s+")

type AuthenticatedAssertion struct {
	assertion *types.Assertion
	subjectConfimationMethod string
}

type TokenAuthenticator struct {
	validationContext *dsig.ValidationContext
	samlServiceProvider *saml2.SAMLServiceProvider
	validateSamlConstraints bool
}

func NewTokenAuthenticator(certPath string, validateSamlConstraints bool) *TokenAuthenticator {
        caCert, err := ioutil.ReadFile(certPath)
        block, _ := pem.Decode([]byte(caCert))
        cert, err := x509.ParseCertificate(block.Bytes)
	if (err != nil) {
		panic(err)
	}
        context := dsig.NewDefaultValidationContext(&dsig.MemoryX509CertificateStore{
                Roots: []*x509.Certificate { cert },
        })


	t := new(TokenAuthenticator)
	t.validationContext = context
	sp := new(saml2.SAMLServiceProvider)
	t.samlServiceProvider = sp
	t.validateSamlConstraints = validateSamlConstraints
	return t;
}

func (t TokenAuthenticator) Authenticate(sessionStore *SessionStore, clientCert *x509.Certificate, r *http.Request) (string, error) {
	path := r.URL.Path
	if (path == "/authenticate") {
		body, err := ioutil.ReadAll(r.Body)
		if (err != nil) {
			return "", err
		}
		return t.processAuthenticationRequest(sessionStore, clientCert, body)
	}

	return "", nil
}


func (t TokenAuthenticator) processAuthenticationRequest(sessionStore *SessionStore, clientCert *x509.Certificate, body []byte) (string, error) {

	// Retrive the assertion from the body
	assertionStr := strings.TrimPrefix(string(body), "saml-token=")

	// Parse the assertion
	_, err := t.ParseAndValidateAuthenticationRequestPayload(assertionStr, clientCert)
	if (err != nil) {
		return "", err
	}

	return "1224", err
}

func (t TokenAuthenticator) ParseAndValidateAuthenticationRequestPayload(body string, clientCert *x509.Certificate) (*AuthenticatedAssertion, error) {

        // Base64 decode
        decoded, err := base64.StdEncoding.DecodeString(body)

	// Validate signature of the issuer of the Assertion
	doc := etree.NewDocument()
	err = doc.ReadFromBytes(decoded)
	if (err != nil) {
		return nil, err
	}
	_, err = t.validationContext.Validate(doc.Root())
    	if (err != nil) {
		return nil, err
    	}

        // Parse the assertion
        assertion := &types.Assertion{}
        xmlDecoder := xml.NewDecoder(bytes.NewReader(decoded))
        xmlDecoder.CharsetReader = identReader
        err = xmlDecoder.Decode(&assertion)
	if (err != nil) {
		return nil, err
	}

	// TODO: Check assertion is valid according to SAML specification
	if (t.validateSamlConstraints) {

		warningInfo, err := t.samlServiceProvider.VerifyAssertionConditions(assertion)
		if (err != nil) {
			return nil, err
		}
		if (warningInfo != nil && warningInfo.InvalidTime) {
			return nil, fmt.Errorf("SAML Assertion was not valid due to invalid time")
		}
	}

	// TODO: Compare KeyInfo from subject (HoK)
	if (clientCert != nil) {
		subjectKeyInfoPath, err := etree.CompilePath("./Assertion/Subject/SubjectConfirmation/SubjectConfirmationData/KeyInfo")
		if (err != nil) {
			panic(err)
		}
		keyInfoElement := doc.FindElementPath(subjectKeyInfoPath)
		if (keyInfoElement != nil) {
			keyInfoDoc := etree.NewDocument()
			keyInfoDoc.SetRoot(keyInfoElement)
			keyInfoDocStr, err := keyInfoDoc.WriteToString()
			if (err != nil) {
				return nil, err
			}
			keyInfo := &dsigtypes.KeyInfo{}
			fmt.Println("*****")
			fmt.Println(keyInfoDocStr)
			fmt.Println("*****")

			keyInfoDecoder := xml.NewDecoder(bytes.NewReader([]byte(keyInfoDocStr)))
			keyInfoDecoder.CharsetReader = identReader
        		err = keyInfoDecoder.Decode(&keyInfo)
			if (err != nil) {
				return nil, err
			}

			if (len(keyInfo.X509Data.X509Certificates) > 0) {
				certData, err := base64.StdEncoding.DecodeString(whiteSpace.ReplaceAllString(keyInfo.X509Data.X509Certificates[0].Data, ""))
				if (err != nil) {
					return nil, err
				}
				_, err = x509.ParseCertificate(certData)
				if (err != nil) {
					return nil, err
				}
			} else {
				fmt.Println("1*****")
				modulusPath, _ := etree.CompilePath("./KeyInfo/KeyValue/RSAKeyValue/Modulus")
				exponentPath, _ := etree.CompilePath("./KeyInfo/KeyValue/RSAKeyValue/Exponent")

				modulusElement := keyInfoDoc.FindElementPath(modulusPath)
				exponentElement := keyInfoDoc.FindElementPath(exponentPath)

				if (modulusElement != nil && exponentElement != nil) {
					modulusValue := modulusElement.Text()
					//exponentValue := exponentElement.Text()

					fmt.Println(fmt.Sprintf("11***** %s", modulusValue))
					decModulusValue, _ := base64.RawURLEncoding.DecodeString(modulusValue) //base64.StdEncoding.DecodeString(modulusValue)
					modulus := big.NewInt(0)
					modulus.SetBytes(decModulusValue)

					e := 65537
					/*decE, _ := base64.StdEncoding.DecodeString(exponentValue)
					var eBytes []byte
					if (len(decE) < 8) {
						eBytes = make([]byte, 8-len(decE), 8)
						eBytes = append(eBytes, decE...)
					} else {
						eBytes = decE
					}
					eReader := bytes.NewReader(eBytes)
					var e uint64
					err = binary.Read(eReader, binary.BigEndian, &e)*/

					pKey := &rsa.PublicKey{N: modulus, E: e}
					fmt.Println("12*****")
					pubBytes, err := x509.MarshalPKIXPublicKey(pKey)
					if (err != nil) {
						return nil, fmt.Errorf("Could not marshal public key from token")
					}
					block := &pem.Block{ Type: "RSA PUBLIC KEY", Bytes: pubBytes }

					var out bytes.Buffer
					pem.Encode(&out, block)
					fmt.Println("FÃ˜RSTE CERT")
					fmt.Println(out.String())

					fmt.Println("13*****")
					if (clientCert != nil) {
						clientCertPubBytes, _ := x509.MarshalPKIXPublicKey(clientCert.PublicKey)
						block2 := &pem.Block{ Type: "RSA PUBLIC KEY", Bytes: clientCertPubBytes }

	                                        var out2 bytes.Buffer
        	                                pem.Encode(&out2, block2)
						fmt.Println("ANDET CERT")

                	                        fmt.Println(out2.String())

						clientCertPubBytesStr := string(clientCertPubBytes)
						pubBytesStr := string(pubBytes)

						fmt.Println(fmt.Sprintf("To compare '%s' and '%s'", clientCertPubBytesStr, pubBytesStr))
						if (pubBytesStr != clientCertPubBytesStr) {
							return nil, fmt.Errorf("HoK constraints not valid")
						}
						/*if (clientCert.PublicKey.N.Cmp(modulus) != 0) {
							errorMsg := fmt.Sprintf("Modulus dont match: %d != %d", clientCert.PublicKey.N, modulus); 
							fmt.Println(errorMsg)
							return nil, fmt.Errorf(errorMsg);
						}
						if (clientPub.E != pKey.E) {
                                                        errorMsg := fmt.Sprintf("Exponents dont match: %d != %d", clientPub.E, pKey.E); 
                                                        fmt.Println(errorMsg)
                                                        return nil, fmt.Errorf(errorMsg);
						}*/
					}
				} else {
					panic("de var nil")
				}

				return nil, fmt.Errorf("Certificate not found in KeyInfo in Assertion (assertion:'%s')", decoded)
			}
			panic("temp")
		} else {
			return nil, fmt.Errorf("KeyInfo not found in assertion (assertion:'%s')", decoded)
		}
	}

	auth :=	AuthenticatedAssertion{}
	auth.assertion = assertion

	return &auth, err
}

func identReader(encoding string, input io.Reader) (io.Reader, error) {
    return input, nil
}

